## 记录管理器

事务管理器能够在磁盘块上的指定位置读写值。但是，它不知道块中有哪些值，也不知道这些值可能位于何处。这是记录管理器的职责。它将一个文件组织成一个记录集合，并具有遍历记录并在其中放置值的方法。

### 1. 设计记录管理器

所以记录管理器必须解决几个问题，例如：

+ 每个记录是否应该完全放在一个区块内？
+ 一个块中的所有记录是否都来自同一个表？
+ 每个字段是否可以使用预定的字节数来表示？
+ 每个字段值应在其记录中放置的位置？

#### 1.1 跨区与非跨区记录

假设记录管理器需要在一个文件中插入四个 300 字节的记录，其中块大小为 1000字节。前三条记录很好地符合块的前 900 个字节。但对于第四个块，记录管理器应该怎么处理记录？

以下是两种处理方法：![image-20230215191652764](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230215191652764.png)

在图（a）中，记录管理器创建了一个跨区记录，即其值跨越了两个或多个块的记录。它将记录前的100个字节存储在现有块中，然后将记录的后200字节存储在新块中。在图（b）中记录将整个第四条记录存储在新块中。

非跨区记录的缺点有：

+ 浪费磁盘空间
+ 限制记录的大小要小于块，否则记录无法存储在一个块中

跨区存储的缺点有：

+ 增加了记录访问的复杂性，因为一个跨区记录被分割在几个块中，所以需要访问多个块来读取它。

#### 1.2 同构与非同构文件

如果一个文件的所有记录都来自同一个表，则该文件是同构的。记录管理器必须决定是否允许非同构文件。

例如：STUDENT表与DEPT表。一个同构的实现是把所有的学生记录放在一个文件中，，所有的系记录放在另一个文件中。这种布局是的单表SQL查询很容易，记录管理器只需要扫描一个文件的块。但是多表查询的效率会降低。考虑一个连接这两个表的查询，例如“查找学生及其主要部门的名称”。记录管理器必须再学生记录块和部门记录块之间来回查找，以查找匹配的记录。即使可以在不进行过多搜索的情况下执行查询（索引），磁盘驱动器仍必须反复查找，因为它会交替读取学生和部门块。

非同构组织方式将学生和系的记录存放在同一文件中，每个学生的记录存储在其主要系附近。这种组织方式需要较少的块访问来计算联接，因为联接的记录聚集在同一个（或附近）块上。

集群提高了连接聚集表的查询的效率，因为匹配的记录被存储在一起。但是，集群将导致单表查询变得效率降低，因为每个表的记录都分散在更多的块上。类似地，与其他表的连接也会导致效率较低。因此，只有当使用最多的查询执行由集群编码的连接时，集群才有效。

#### 1.3 固定长度与可变长度

表中的每个字段都有定义的类型。根据该类型，记录管理器决定是使用固定长度表示还是可变长度表示来实现字段。固定长度表示使用完全相同的字节数来存储每个字段的值，而可变长度表示则基于存储的数据值展开和收缩。

大多数类型是自然固定长度。如整数和浮点型都可以存储为4字节二进制值。事实上，所有数字和日期/时间类型都有自然的固定长度表示。

可变长度表示可能会导致严重的问题。例如，考虑一个位于一个由记录组成的块中间的记录并修改了它的一个字段值。如果字段长度是固定的，那么记录的大小将保持不变，并且可以就地修改字段。但是如果字段是可变长度的，那么记录可能会变大。为了给较大的记录腾出空间，记录管理器可能必须重新安排块中记录的位置。事实上，如果修改后的记录太大，则可能需要将一个或多个记录移出块并放置到另一个块中。

因此，只要有可能，记录管理器会尽可能使用固定长度的表示形式。例如，记录管理器可以从字符串字段的三种不同表示形式中进行选择：

+ 可变长度表示法，其中记录管理器在记录中分配字符串所需的确切空间量。
+ 一种固定长度的表示法，其中记录管理器将字符串存储在记录之外的某个位置，并在记录中保留对该位置的固定长度引用。
+ 一种固定长度的表示法，其中记录管理器在记录中为每个字符串分配相同数量的空间，而不考虑其长度。

![image-20230225211014998](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225211014998.png)

+ 第（a）部分显示了三个课程记录，其中标题字段使用可变长度表示法实现。这些记录节省空间，但存在刚刚讨论过的问题。
+ 第（b）部分显示了相同的三个记录，但是标题字符串放在一个单独的“字符串区域”。这个区域可以是一个单独的文件，或者（如果字符串非常大）每个字符串都存储在自己的文件中的目录。无论哪种情况，字段都包含对字符串在该区域中位置的引用。这种表示会产生固定长度和较小的记录。小记录是好的，因为它们可以存储在更少的块中，因此需要更少的块访问。这种表示的缺点是从记录中检索字符串值需要额外的块访问。
+ 第（c）部分显示了其中两个记录，使用固定长度的标题字段实现。这种实现的优点是记录是固定长度的，字符串存储在记录中。然而，缺点是有些记录会比需要的大。如果字符串大小有很大的差异，那么图6.3 浪费的空间将是显著的，从而导致更大的文件和相应的更多的块访问。

这些方式中没有一种明显比其他的表现好。为了帮助记录管理器选择正确的表示，标准SQL体重了三种不同的字符串数据类型：char、varchar和clob。char(n)类型指定的字符串正还是n个字符。varchar(n)和clob(n)类型指定最多n个字符的字符串，他们的区别是n的预期大小。在varchar(n)中，n相对小，比如不超过4K。另一方面，clob(n)中n的值可以在千兆字符范围内（CLOB 的缩写是字符大对象）。

对于clob字段的一个示例，假设大学数据库将字段教学大纲添加到其数据表中，并认为该字段的值将包含每个部分的教学大纲的文本。假设提纲不能超过8000个字符，您可以合理地将字段定义为clob（8000）。

+ char 类型的字段最自然地对应于图6.3c。由于所有字符串的长度相同，因此在记录中没有浪费空间，固定长度的表示将是最有效的。
+ varchar（n）类型的字段最自然地对应于图6.3a。由于n 相对较小，将字符串放入记录中不会使记录太大。此外，字符串大小的差异意味着固定长度表示将浪费空间。因此，变长表示是最好的选择。如果n 恰好很小（比如小于20），那么记录管理器可能会选择使用第三种表示来实现varchar 字段。原因是，与固定长度表示的好处相比，浪费的空间将微不足道。
+ clob 类型的字段对应于图6.3b，因为这种表示法处理大字符串的效果最好。通过
    将大字符串存储在记录之外，记录本身变得更小、更易于管理。

#### 1.4在记录中放置字段

记录管理器决定其记录的结构。在每个记录的固定长度内确定记录的位置。最直接的策略是将字段彼此相邻存储。然后，记录的大小变成字段大小的总和，每个字段的偏移量是前一个字段的结尾。

这种将字段紧密打包到记录中的策略适用于基于Java 的系统（如SimpleDB 和Derby），但可能会在其它地方造成问题。问题在于确保值在内存中正确对齐。在大多数计算机中，访问整数的机器代码要求将整数存储在4 的倍数的内存位置；整数被称为在4 字节边界上对齐。因此，记录管理器必须确保每个页中的每个整数都在4 字节边界上对齐。由于操作系统页面总是在2^N字节的边界上对齐，所以每个页面的第一个字节将被正确对齐。因此，记录管理器必须简单地确保每个页中每个整数的偏移量是4 的倍数。如果前一个字段的结束位置不是4 的倍数，那么记录管理器必须用足够的字节填充它，这样它就可以了。

例如，考虑STUDENT 表，它由三个整数字段和一个varchar(10)字符串字段组成。整数字段是4 的倍数，因此不需要填充。但是，string 字段需要14（额外的4字节用于记录字符串长度） 个字节；因此需要用2 个额外的字节来填充它，这样它后面的字段将以4 的倍数对齐。

一般来说，不同的类型可能需要不同的填充量。例如，双精度浮点数通常在8 字节边界上对齐，小整数通常在2 字节边界上对齐。记录管理员负责确保这些对齐。一个简单的策略是按照声明的顺序定位字段，填充每个字段以确保下一个字段的正确对齐。一个更聪明的策略是对字段重新排序，这样所需的填充量最少。例如，
考虑以下SQL 表声明：

```sql
create table T (A smallint, B double precision, C smallint, D int, E int)
```

假设字段按给定的顺序存储。然后字段A 需要填充6 个额外字节，字段C 需要填充2 个额外字节，导致记录长度为28 字节((2+6)+(8)+(2+2)+(4)+(4))；见图6.4a。另一方面，如果字段按[B、D、A、C、E]的顺序存储，则不需要填充，记录长度仅为20 个字节，如图6.4b 所示：

![image-20230225213702954](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225213702954.png)

除了填充字段外，记录管理器还必须填充每个记录。其思想是，每个记录都需要以k字节边界结束，其中k是支持的最大对齐方式，这样页面中的每个记录都与第一个记录具有相同的对齐方式。再次考虑图6.4a 的字段位置，其记录长度为28字节。假设第一条记录从块的字节0 开始。然后第二条记录将从块的字节28 开始，这意味着第二条记录的字段B 将从块的字节36 开始，这是错误的对齐方式。每个记录都必须从8 字节的边界开始。在图6.4 的例子中，部分（a）和部分（b）的记录都需要用4 个额外的字节填充。

Java 程序不需要考虑填充，因为它不能直接访问字节数组中的数值。例如，从页面读取整数的Java 方法是`ByteBuffer.getInt`. 此方法不调用机器码指令来获取整数，而是从数组的4 个指定字节构造整数本身。此函数的效率低于单个机器代码指令，但它避免了对齐问题。

### 2. 实现一个记录文件

#### 2.1 一个简单的实现

假设要创建一个同质、未跨区、固定长度记录的文件。记录是未跨区的这一事实意味着可以将文件视为一系列块，其中每个块包含其自己的记录。事实上，记录是同质和固定长度的，这意味着您可以为块中的每个记录分配相同数量的空间。换句话说，可以将每个块看作一个记录数组。SimpleDB将这样的块称为记录页。

记录管理器可以实现如下记录页。它将一个块分成多个插槽，每个插槽都足够大，足以容纳一个记录加上一个额外的字节。这个字节的值是一个标志，表示插槽是空的还是正在使用的；假设0 表示“空”，1 表示“正在使用”。

例如，假设块大小为400，记录大小为26；那么每个槽的长度为27 个字节，块包含14 个插槽，其中22 个字节浪费了空间。图6.5 描述了这种情况。此图显示了14 个插槽中的4 个；插槽0和13当前包含记录，而插槽1和2为空。

![image-20230225214319972](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225214319972.png)

记录管理器需要能够在记录页中插入、删除和修改记录。为此，它使用以下有关记录的信息：

+ 插槽大小
+ 记录中每个字段的名称、类型、长度和偏移量

这些值构成了记录的布局。例如：考虑如图2.4中定义的表STUDENT。学生记录包含三个整数加上一个10个字符的varchar字段。假设SimpleDB的存储策略，每个整数需要4 个字节，10 个字符的字符串需要14 个字节。我们还假设填充是不必要的，varchar字段是通过为最大可能的字符串分配固定空间来实现的，并且empty/inuse 标志在每个插槽的开头占用一个字节。图6.6 给出了该表的最终布局。给定一个布局，记录管理器可以确定页面中每个值的位置。槽k中的记录从位置RL\*k 开始，其中RL是记录长度。该记录的empty/inuse 标志位于位置RL\*k，其字段F的值位于位置RL\*k+偏移量（F）。record manager 可以非常轻松地处理插入、删除、修改和检索：

![image-20230225231259311](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225231259311.png)

#### 2.2 实现可变长字段

一个问题是记录中的字段偏移不再固定。特别是，可变长度字段后面的所有字段的偏移量将因记录而异。确定这些字段偏移量的唯一方法是读取前一个字段并查看其结束位置。如果记录中的第一个字段是可变长度的，则需要读取记录的前n-1个字段，以确定第n 个字段的偏移量。因此，记录管理器通常将固定长度字段放在每个记录的开头，以便可以通过预计算的偏移量访问这些字段。可变长度字段放在记录的末尾。第一个可变长度字段将具有固定的偏移量，但其余字段不会。另一个问题是修改字段值会导致记录的长度发生更改。如果新值较大，则必须移动修改后的值右侧的块内容以腾出空间。在极端情况下，移位的记录将溢出块；这种情况必须通过分配溢出块来处理。

溢出块是从称为溢出区域的区域分配的新块。从原始块溢出的任何记录都将从该块中移除并添加到溢出块中。如果发生许多这样的修改，那么可能需要几个溢出块的链。每个块将包含对链上下一个溢出块的引用。从概念上讲，原始块和溢出块形成一个（大）记录页。

例如，考虑课程表，假设课程标题保存为可变长度字符串。图6.7a 描述了一个包含表的前三个记录的块。（Title 字段被移到记录的末尾，因为其它字段的长度是固定的。）图6.7b 描述了将标题“DbSys”修改为“数据库系统实现”的结果。假设块大小为80 字节，第三条记录不再适合该块，因此它被放在溢出块中。原始块包含对该溢出块的引用。

![image-20230308171306974](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308171306974.png)

第三个问题涉及使用插槽号作为记录标识符。再也不可能像固定长度记录那样，将插槽编号乘以插槽大小。找到具有给定id 的记录开头的唯一方法是从块的开头开始读取记录。
使用槽号作为记录标识符也会使记录插入复杂化。图6.8 说明了这个问题。

![image-20230308171422671](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308171422671.png)

第（a）部分描述了一个包含前三个过程记录的块，如图6.7a 所示。删除第22 个过程的记录将标志设置为0（表示“空”），并保持记录不变，如第（b）部分所示。此空间现在可用于插入。但是，只有当记录的标题字段包含9 个或更少的字符时，才能将其插入到空格中。通常，新记录可能无法放入块中，即使较小的已删除记录会留下许多空白。这个块是没有被充分利用。

这个问题的解决方案是使用ID 表将记录的槽号与其在页面中的位置分离。ID 表是存储在页面开头的整数数组。数组中的每个槽表示一个记录id。数组槽中的值是具有该id 的记录的位置；值为0 表示当前没有该id 的记录。图6.8c 描述了与图6.8b 相同的数据，但有一个id 表。ID 表包含三个条目：其中两个指向块偏移量63和43 处的记录，另一个是空的。位置63 处的记录的id 为0，位置43 处的记录的id 为2。当前没有id 为1 的记录。

ID 表提供了一个间接级别，允许记录管理器在块内移动记录。如果记录移动，则其在ID 表中的条目将相应调整；如果记录被删除，则其条目设置为0。插入新记录时，记录管理器会在数组中找到一个可用的条目，并将其指定为新记录的id。通过这种方式，ID 表允许在一个块中移动可变长度的记录，同时为每个记录提供一个固定的标识符。

ID 表随着块中记录数的增加而扩展。数组的大小必然是可修改的，因为一个块可以保存不同数量的可变长度记录。通常，ID 表放在块的一端，而记录放在另一端，并且它们彼此增长。这种情况可以在图6.8c 中看到，其中块中的第一个记录在其最右侧。

ID 表使empty/inuse 标志不必要。如果ID 表的某个条目指向某个记录，则该记录正在使用中。空记录的id 为0（实际上根本不存在）。ID 表还允许记录管理器快速查找块中的每条记录。要移动到具有特定id 的记录，记录管理器只需使用id 表中该条目中存储的位置；要移动到下一个记录，记录管理器将跨区id 表，直到找到下一个非零条目。

#### 2.3 实现跨越式记录

当记录取消跨区时，每个块中的第一个记录总是从同一个位置开始。有了跨越式的记录，这种情况就不再是真的了。因此，记录管理器必须在每个块的开头存储一个整数，以保持第一个记录的偏移量。

例如，考虑图6.9。块0 中的第一个整数是4，表示第一个记录R1 从偏移量4 开始（即，紧跟在整数之后）。记录R2 跨越了块0 和块1，因此块1 中的第一条记录是R3，从偏移量60 开始。记录R3 从块2 到块3。记录R4 是块3 中的第一个记录，从偏移量30 开始。注意，块2 的第一个整数是0，表示没有记录在该块中开始。

记录管理器可以选择用两种不同的方式拆分跨区记录。第一种方法是尽可能多地填充块，在块边界上拆分它；剩余的字节放入文件的下一个块中。第二种方法是逐值写入记录值；当页面变满时，将在新页面上继续写入。第一种方法的优点是绝对不浪费空间，但缺点是将值拆分为多个块。要访问分割值，记录管理器必须通过将两个块中的字节连接起来来重建该值。

![image-20230308172339554](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308172339554.png)

#### 2.4 实现非同质记录

如果记录管理器支持非同构记录，那么它也需要支持可变长度的记录，因为不同表中的记录不需要大小相同。在块中有两个与非同质记录相关的问题：

+ 记录管理器需要知道块中每种类型记录的布局。
+ 给定一个记录，记录管理器需要知道它来自哪个表。

记录管理器可以通过保留一个布局数组来解决第一个问题，每个可能的表都有一个布局。记录管理器可以通过在每个记录的开头添加一个额外的值来解决第二个问题；这个值（有时称为标记值）是布局数组的索引，该数组指定记录所属的表。

### 3. DB记录页

#### 3.1 记录信息管理

![image-20230308174810429](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308174810429.png)

![image-20230308174818958](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308174818958.png)

Schema 对象保存记录的模式，即每个字段的名称和类型，以及每个字符串字段的长度。此信息与用户在创建表时指定的信息相对应，不包含物理信息。例如，字符串的长度是允许的最大字符数，而不是其字节大小。

模式可以被认为是一个三元组的列表，形式为`[fieldname，type，length]`。类模式包含五个向列表中添加三元组的方法。`addField` 方法显式地添加一个三元组。`addIntField`、`addStringField`、`add` 和`addAll` 方法是方便的方法；前两个方法计算三元组，最后两个复制三元组来自现有架构。该类还具有用于检索字段名集合、确定指定字段是否在集合中以及检索指定字段的类型和长度的访问器方法。
类布局还包含有关记录的物理信息。它计算字段和插槽大小，以及插槽中的字段偏移。该类有两个构造函数，对应于创建布局对象的两个原因。创建表时调用第一个构造函数；它根据给定的架构计算布局信息。在创建表之后调用第二个构造函数；客户机只提供先前计算的值。

![image-20230308175333913](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308175333913.png)

图6.11 中的代码片段说明了这两个类的用法。代码的第一部分创建一个包含课程表的三个字段的模式，然后从中创建一个布局对象。代码的第二部分打印每个字段的名称和偏移量。

![image-20230308175615662](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308175615662.png)

类型由常量INTEGER 和VARCHAR 表示，如JDBC 类类型中定义的那样。字段的长度只对字符串字段有意义；addIntField 方法给整数一个长度值0，但这个值无关紧要，因为它永远不会被访问。布局代码如图6.13 所示。

![image-20230308175647131](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308175647131.png)

第一个构造函数按照字段在模式中出现的顺序来定位字段。它以字节为单位确定每个字段的长度，将插槽大小计算为字段长度之和，为整数大小的空/正在使用标志添加四个字节。它将标志指定在槽的偏移量0 处，并将每个字段的偏移量指定为上一个字段结束的位置（即，没有填充）。

#### 3.2 管理页面中的记录

![image-20230308175753350](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308175753350.png)

方法nextAfter 和insertAfter 在页面中搜索所需的记录。nextAfter 方法返回指定插槽后面的第一个使用的插槽，跳过任何空插槽。负返回值表示所有剩余的插槽都是空的。方法insertAfter查找指定插槽后面的第一个空插槽。如果找到空槽，则该方法将其标志设置为USED 并返回槽号。否则，该方法返回-1。
get/set 方法访问指定记录中指定字段的值。delete 方法将记录的标志设置为空。format 方法为页中的所有记录槽提供默认值。它将每个empty/inuse 标志设置为空，将所有整数设置为0，将所有字符串设置为“”。

![image-20230308181706227](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308181706227.png)

![image-20230308181714073](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308181714073.png)

offset方法 使用槽大小来计算记录槽的起始位置。get/set 方法通过将字段的偏移量添加到记录的偏移量来计算其指定字段的位置。方法nextAfter 和insertAfter分别调用私有方法searchAfter 来查找具有指定标志USED 或空的插槽。方法searchAfter 重复增加指定的插槽，直到找到具有指定标志的插槽或插槽用完为止。delete 方法将指定插槽的标志设置为空，insertAfter 将找到的插槽的标志设置为USED。

### 4. 表跨区

![image-20230308181945634](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230308181945634.png)

TableScan 对象跟踪当前记录，其方法更改当前记录并访问其内容。beforeFirst 方法将当前记录放在文件的第一条记录之前，next 将当前记录定位到文件中的下一条记录。如果当前块没有更多的记录，则next 将读取文件中的后续块，直到找到另一个记录为止。如果找不到更多的记录，则调用next 返回false。get/set 和delete 方法应用于当前记录。insert 方法在文件中的某个地方插入一个新记录，从当前记录的块开始。与RecordPage 的插入方法不同，此插入方法总是成功的；如果在文件的现有块中找不到插入记录的位置，它会向文件追加一个新的块并在那里插入记录。

文件中的每个记录都可以通过一对值来标识：它在文件中的块号和它在块中的槽。这两个值被称为记录标识符（或rid）。实现这些记录标识符。它的类构造函数保存这两个值；访问器方法blockNumber 和slot 检索它们。TableScan 类包含两个与rid 交互的方法。方法moveToId 将当前记录定位在指定的rid，方法currentRid 返回当前记录的rid。TableScan 类提供的抽象级别与您目前看到的其它类有很大不同。也就是说，Page、Buffer、Transaction 和RecordPage 的方法都适用于特定的块。另一方面，TableScan类对其客户端隐藏块结构。一般来说，客户端不会知道（或关心）当前正在访问哪个块。

