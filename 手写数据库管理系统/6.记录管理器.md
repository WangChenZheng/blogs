## 记录管理器

事务管理器能够在磁盘块上的指定位置读写值。但是，它不知道块中有哪些值，也不知道这些值可能位于何处。这是记录管理器的职责。它将一个文件组织成一个记录集合，并具有遍历记录并在其中放置值的方法。

### 1. 设计记录管理器

所以记录管理器必须解决几个问题，例如：

+ 每个记录是否应该完全放在一个区块内？
+ 一个块中的所有记录是否都来自同一个表？
+ 每个字段是否可以使用预定的字节数来表示？
+ 每个字段值应在其记录中放置的位置？

#### 1.1 跨区与非跨区记录

假设记录管理器需要在一个文件中插入四个 300 字节的记录，其中块大小为 1000字节。前三条记录很好地符合块的前 900 个字节。但对于第四个块，记录管理器应该怎么处理记录？

以下是两种处理方法：![image-20230215191652764](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230215191652764.png)

在图（a）中，记录管理器创建了一个跨区记录，即其值跨越了两个或多个块的记录。它将记录前的100个字节存储在现有块中，然后将记录的后200字节存储在新块中。在图（b）中记录将整个第四条记录存储在新块中。

非跨区记录的缺点有：

+ 浪费磁盘空间
+ 限制记录的大小要小于块，否则记录无法存储在一个块中

跨区存储的缺点有：

+ 增加了记录访问的复杂性，因为一个跨区记录被分割在几个块中，所以需要访问多个块来读取它。

#### 1.2 同构与非同构文件

如果一个文件的所有记录都来自同一个表，则该文件是同构的。记录管理器必须决定是否允许非同构文件。

例如：STUDENT表与DEPT表。一个同构的实现是把所有的学生记录放在一个文件中，，所有的系记录放在另一个文件中。这种布局是的单表SQL查询很容易，记录管理器只需要扫描一个文件的块。但是多表查询的效率会降低。考虑一个连接这两个表的查询，例如“查找学生及其主要部门的名称”。记录管理器必须再学生记录块和部门记录块之间来回查找，以查找匹配的记录。即使可以在不进行过多搜索的情况下执行查询（索引），磁盘驱动器仍必须反复查找，因为它会交替读取学生和部门块。

非同构组织方式将学生和系的记录存放在同一文件中，每个学生的记录存储在其主要系附近。这种组织方式需要较少的块访问来计算联接，因为联接的记录聚集在同一个（或附近）块上。

集群提高了连接聚集表的查询的效率，因为匹配的记录被存储在一起。但是，集群将导致单表查询变得效率降低，因为每个表的记录都分散在更多的块上。类似地，与其他表的连接也会导致效率较低。因此，只有当使用最多的查询执行由集群编码的连接时，集群才有效。

#### 1.3 固定长度与可变长度

表中的每个字段都有定义的类型。根据该类型，记录管理器决定是使用固定长度表示还是可变长度表示来实现字段。固定长度表示使用完全相同的字节数来存储每个字段的值，而可变长度表示则基于存储的数据值展开和收缩。

大多数类型是自然固定长度。如整数和浮点型都可以存储为4字节二进制值。事实上，所有数字和日期/时间类型都有自然的固定长度表示。

可变长度表示可能会导致严重的问题。例如，考虑一个位于一个由记录组成的块中间的记录并修改了它的一个字段值。如果字段长度是固定的，那么记录的大小将保持不变，并且可以就地修改字段。但是如果字段是可变长度的，那么记录可能会变大。为了给较大的记录腾出空间，记录管理器可能必须重新安排块中记录的位置。事实上，如果修改后的记录太大，则可能需要将一个或多个记录移出块并放置到另一个块中。

因此，只要有可能，记录管理器会尽可能使用固定长度的表示形式。例如，记录管理器可以从字符串字段的三种不同表示形式中进行选择：

+ 可变长度表示法，其中记录管理器在记录中分配字符串所需的确切空间量。
+ 一种固定长度的表示法，其中记录管理器将字符串存储在记录之外的某个位置，并在记录中保留对该位置的固定长度引用。
+ 一种固定长度的表示法，其中记录管理器在记录中为每个字符串分配相同数量的空间，而不考虑其长度。

![image-20230225211014998](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225211014998.png)

+ 第（a）部分显示了三个课程记录，其中标题字段使用可变长度表示法实现。这些记录节省空间，但存在刚刚讨论过的问题。
+ 第（b）部分显示了相同的三个记录，但是标题字符串放在一个单独的“字符串区域”。这个区域可以是一个单独的文件，或者（如果字符串非常大）每个字符串都存储在自己的文件中的目录。无论哪种情况，字段都包含对字符串在该区域中位置的引用。这种表示会产生固定长度和较小的记录。小记录是好的，因为它们可以存储在更少的块中，因此需要更少的块访问。这种表示的缺点是从记录中检索字符串值需要额外的块访问。
+ 第（c）部分显示了其中两个记录，使用固定长度的标题字段实现。这种实现的优点是记录是固定长度的，字符串存储在记录中。然而，缺点是有些记录会比需要的大。如果字符串大小有很大的差异，那么图6.3 浪费的空间将是显著的，从而导致更大的文件和相应的更多的块访问。

这些方式中没有一种明显比其他的表现好。为了帮助记录管理器选择正确的表示，标准SQL体重了三种不同的字符串数据类型：char、varchar和clob。char(n)类型指定的字符串正还是n个字符。varchar(n)和clob(n)类型指定最多n个字符的字符串，他们的区别是n的预期大小。在varchar(n)中，n相对小，比如不超过4K。另一方面，clob(n)中n的值可以在千兆字符范围内（CLOB 的缩写是字符大对象）。

对于clob字段的一个示例，假设大学数据库将字段教学大纲添加到其数据表中，并认为该字段的值将包含每个部分的教学大纲的文本。假设提纲不能超过8000个字符，您可以合理地将字段定义为clob（8000）。

+ char 类型的字段最自然地对应于图6.3c。由于所有字符串的长度相同，因此在记录中没有浪费空间，固定长度的表示将是最有效的。
+ varchar（n）类型的字段最自然地对应于图6.3a。由于n 相对较小，将字符串放入记录中不会使记录太大。此外，字符串大小的差异意味着固定长度表示将浪费空间。因此，变长表示是最好的选择。如果n 恰好很小（比如小于20），那么记录管理器可能会选择使用第三种表示来实现varchar 字段。原因是，与固定长度表示的好处相比，浪费的空间将微不足道。
+ clob 类型的字段对应于图6.3b，因为这种表示法处理大字符串的效果最好。通过
    将大字符串存储在记录之外，记录本身变得更小、更易于管理。

#### 1.4在记录中放置字段

记录管理器决定其记录的结构。在每个记录的固定长度内确定记录的位置。最直接的策略是将字段彼此相邻存储。然后，记录的大小变成字段大小的总和，每个字段的偏移量是前一个字段的结尾。

这种将字段紧密打包到记录中的策略适用于基于Java 的系统（如SimpleDB 和Derby），但可能会在其它地方造成问题。问题在于确保值在内存中正确对齐。在大多数计算机中，访问整数的机器代码要求将整数存储在4 的倍数的内存位置；整数被称为在4 字节边界上对齐。因此，记录管理器必须确保每个页中的每个整数都在4 字节边界上对齐。由于操作系统页面总是在2^N字节的边界上对齐，所以每个页面的第一个字节将被正确对齐。因此，记录管理器必须简单地确保每个页中每个整数的偏移量是4 的倍数。如果前一个字段的结束位置不是4 的倍数，那么记录管理器必须用足够的字节填充它，这样它就可以了。

例如，考虑STUDENT 表，它由三个整数字段和一个varchar(10)字符串字段组成。整数字段是4 的倍数，因此不需要填充。但是，string 字段需要14（额外的4字节用于记录字符串长度） 个字节；因此需要用2 个额外的字节来填充它，这样它后面的字段将以4 的倍数对齐。

一般来说，不同的类型可能需要不同的填充量。例如，双精度浮点数通常在8 字节边界上对齐，小整数通常在2 字节边界上对齐。记录管理员负责确保这些对齐。一个简单的策略是按照声明的顺序定位字段，填充每个字段以确保下一个字段的正确对齐。一个更聪明的策略是对字段重新排序，这样所需的填充量最少。例如，
考虑以下SQL 表声明：

```sql
create table T (A smallint, B double precision, C smallint, D int, E int)
```

假设字段按给定的顺序存储。然后字段A 需要填充6 个额外字节，字段C 需要填充2 个额外字节，导致记录长度为28 字节((2+6)+(8)+(2+2)+(4)+(4))；见图6.4a。另一方面，如果字段按[B、D、A、C、E]的顺序存储，则不需要填充，记录长度仅为20 个字节，如图6.4b 所示：

![image-20230225213702954](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225213702954.png)

除了填充字段外，记录管理器还必须填充每个记录。其思想是，每个记录都需要以k字节边界结束，其中k是支持的最大对齐方式，这样页面中的每个记录都与第一个记录具有相同的对齐方式。再次考虑图6.4a 的字段位置，其记录长度为28字节。假设第一条记录从块的字节0 开始。然后第二条记录将从块的字节28 开始，这意味着第二条记录的字段B 将从块的字节36 开始，这是错误的对齐方式。每个记录都必须从8 字节的边界开始。在图6.4 的例子中，部分（a）和部分（b）的记录都需要用4 个额外的字节填充。

Java 程序不需要考虑填充，因为它不能直接访问字节数组中的数值。例如，从页面读取整数的Java 方法是`ByteBuffer.getInt`. 此方法不调用机器码指令来获取整数，而是从数组的4 个指定字节构造整数本身。此函数的效率低于单个机器代码指令，但它避免了对齐问题。

### 2. 实现一个记录文件

#### 2.1 一个简单的实现

假设要创建一个同质、未跨区、固定长度记录的文件。记录是未跨区的这一事实意味着可以将文件视为一系列块，其中每个块包含其自己的记录。事实上，记录是同质和固定长度的，这意味着您可以为块中的每个记录分配相同数量的空间。换句话说，可以将每个块看作一个记录数组。SimpleDB将这样的块称为记录页。

记录管理器可以实现如下记录页。它将一个块分成多个插槽，每个插槽都足够大，足以容纳一个记录加上一个额外的字节。这个字节的值是一个标志，表示插槽是空的还是正在使用的；假设0 表示“空”，1 表示“正在使用”。

例如，假设块大小为400，记录大小为26；那么每个槽的长度为27 个字节，块包含14 个插槽，其中22 个字节浪费了空间。图6.5 描述了这种情况。此图显示了14 个插槽中的4 个；插槽0和13当前包含记录，而插槽1和2为空。

![image-20230225214319972](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225214319972.png)

记录管理器需要能够在记录页中插入、删除和修改记录。为此，它使用以下有关记录的信息：

+ 插槽大小
+ 记录中每个字段的名称、类型、长度和偏移量

这些值构成了记录的布局。例如：考虑如图2.4中定义的表STUDENT。学生记录包含三个整数加上一个10个字符的varchar字段。假设SimpleDB的存储策略，每个整数需要4 个字节，10 个字符的字符串需要14 个字节。我们还假设填充是不必要的，varchar字段是通过为最大可能的字符串分配固定空间来实现的，并且empty/inuse 标志在每个插槽的开头占用一个字节。图6.6 给出了该表的最终布局。给定一个布局，记录管理器可以确定页面中每个值的位置。槽k中的记录从位置RL\*k 开始，其中RL是记录长度。该记录的empty/inuse 标志位于位置RL\*k，其字段F的值位于位置RL\*k+偏移量（F）。record manager 可以非常轻松地处理插入、删除、修改和检索：

![image-20230225231259311](https://image-bed-693a.obs.cn-north-4.myhuaweicloud.com/imgbed/image-20230225231259311.png)
